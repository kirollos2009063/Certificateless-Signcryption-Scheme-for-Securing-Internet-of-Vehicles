#include <omnetpp.h>
#include <Crypto++/sha.h>
#include <Crypto++/sha3.h>
#include <Crypto++/eccrypto.h>
#include <Crypto++/oids.h>
#include <Crypto++/hex.h>
#include <Crypto++/osrng.h>
#include<string>
#include<KeyReqMsg.h>
#include "PrivANDPub.h"


using namespace omnetpp;
using namespace CryptoPP;
using namespace std;
struct GlobalParameters {
    ECP::Point G;          // Base point
    Integer n;             // Order of the subgroup generated by G
    Integer p;             // Prime modulus
    ECP::Point D;          // Generator point
    Integer h;             // Elliptic curve cofactor
    string h1, h2, h3, h4;  // Hash functions
    ECP::Point gamma;         // KGC's public key

    GlobalParameters() : G(), n(), p(), D(), h(), h1(), h2(), h3(), h4(), gamma() {}
};
class KGC : public cSimpleModule {

private:
    Integer private_key;
    ECP::Point public_key;
    map<Integer, Integer> deviceSecretValues;

    DL_GroupParameters_EC<ECP> params;
    int arrivalGate;
    PuB_privMsg *Pb_Pr_Msg;
    int counter=0;
protected:
    virtual void initialize() override;
    virtual void handleMessage(cMessage *msg) override;
public:
    void constructSecretValue(const int& deviceId, const ECP::Point& Od);
    void constructPartialPrivateKey(const int& deviceId, const ECP::Point& Od);
    ECP::Point multiplyScalar(const Integer &k, const ECP::Point &P, const DL_GroupParameters_EC<ECP> &param);
    string PointToString(const ECP::Point& point);
    Integer hash1(string& input);
    Integer hash2(string& input);
    void Setup();
};

Define_Module(KGC);

void KGC::initialize() {
    Setup();
}

void KGC::handleMessage(cMessage *msg) {


      KeyReqMsg *ReqMsg = check_and_cast<KeyReqMsg *>(msg);
      int receivedID = ReqMsg->getID();
      ECP::Point receivedOd = ReqMsg->getOd();

      constructSecretValue(receivedID, receivedOd);
}

void KGC::Setup(){
    params = ASN1::secp256r1();

        string h1="SHA-256";
        string h2="SHA-3";
        string h3="Whirlpool";
        string h4="MD5";

            // Generate eta in the range [0, p]
            AutoSeededRandomPool prng;
            Integer eta(prng, Integer::Zero(), params.GetSubgroupOrder() - 1);
            // Compute gamma = eta * generator point D
            ECP::Point gamma = multiplyScalar(eta,params.GetSubgroupGenerator(),params);

             private_key=eta;
             public_key=gamma;


             // Set global parameter set Xi
             GlobalParameters globalParams;
                 globalParams.G = params.GetSubgroupGenerator();
                 globalParams.n = params.GetSubgroupOrder();
                 globalParams.p = params.GetCurve().GetField().GetModulus();
                 globalParams.D = params.GetSubgroupGenerator();
                 globalParams.h = params.GetCofactor();
                 globalParams.h1 = "SHA-256";
                 globalParams.h2 = "SHA-3";
                 globalParams.h3 = "Whirlpool";
                 globalParams.h4 = "MD5";
                 globalParams.gamma = public_key;

}
void KGC::constructSecretValue(const int& deviceId, const ECP::Point& Od) {
    // Ensure that the device identity is not already in the map
    if (deviceSecretValues.find(deviceId) == deviceSecretValues.end()) {
        // Construct the Secret Value (CSV) using Od
        Integer xCoord = Od.x;
        Integer yCoord = Od.y;

        Integer CSV = xCoord + yCoord;

        // Store the Secret Value in the map
        deviceSecretValues[Integer(deviceId)] = CSV;

    } else {
        EV << "Secret Value (CSV) for device " << deviceId << " is already constructed." << endl;
    }
    constructPartialPrivateKey(deviceId,Od);
}
void KGC::constructPartialPrivateKey(const int& deviceId, const ECP::Point& Od) {
    // Select 𝛿𝑑 where 0 ≤ 𝛿𝑑 ≤ p
    AutoSeededRandomPool prng;
    Integer delta_d(prng, Integer::Zero(), params.GetCurve().GetField().GetModulus() - 1);


    // Compute 𝜁𝑑 = 𝛿𝑑 ⋅ 𝒟
    ECP::Point zeta_d = multiplyScalar(delta_d,params.GetSubgroupGenerator(),params);

    // Calculate 𝜇𝑑 = 𝒽𝑣(𝐼𝐷𝑑, 𝒪𝑑, 𝜁𝑑)
    string IDd_Od_zeta_d = to_string(deviceId) + PointToString(Od) + PointToString(zeta_d);
    Integer mu_d = hash1(IDd_Od_zeta_d);

    // Make 𝛶𝑑 = 𝛿𝑑 + 𝜇𝑑 ⋅ 𝜂
    Integer eta= private_key;
    Integer delta_d_plus_mu_d_eta = delta_d + mu_d * eta;

    // Calculate 𝛽𝑑 = 𝛶𝑑 + 𝒽𝑤(𝐼𝐷𝑑, 𝜂 ⋅ 𝒪𝑑)
    string IDd_eta_Od = to_string(deviceId) +  PointToString(multiplyScalar(eta,Od,params));
    Integer beta_d = delta_d_plus_mu_d_eta + hash2(IDd_eta_Od);

     // send 𝜁𝑑 & 𝛽𝑑 to Car
        Pb_Pr_Msg=new PuB_privMsg ();
        Pb_Pr_Msg->setZeta_d(zeta_d);
        Pb_Pr_Msg->setBeta_d(beta_d);
        Pb_Pr_Msg->setgamma(public_key);

        if(counter==0){
            send(Pb_Pr_Msg,"OutKGC",0);
        }

}

Integer KGC::hash1(string& input){

        SHA256 hash;
        std::string hashDigest;

        StringSource(input, true, new HashFilter(hash, new HexEncoder(new StringSink(hashDigest))));

        Integer result(hashDigest.c_str());

        return result;
}
Integer KGC::hash2(string& input){

    // Create a SHA-3 hash object with a specific digest size (e.g., 256 bits)
        SHA3_256 hash;

        // Calculate the hash of the input
        byte digest[SHA3_256::DIGESTSIZE];
        hash.Update(reinterpret_cast<const byte*>(input.data()), input.size());
        hash.Final(digest);

        // Convert the digest to an Integer
        Integer hashResult;
        hashResult.Decode(digest, SHA3_256::DIGESTSIZE);

        return hashResult;

}
ECP::Point KGC::multiplyScalar(const Integer &k, const ECP::Point &P, const DL_GroupParameters_EC<ECP> &param)
{

    ECP ec = param.GetCurve();  // Get the curve from Params
    ECP::Point result= ec.ScalarMultiply(P, k);

    return result;

}
string KGC:: PointToString(const ECP::Point& point)
{
        string encodedX, encodedY;
        HexEncoder xEncoder(new StringSink(encodedX));
        HexEncoder yEncoder(new StringSink(encodedY));

        point.x.Encode(xEncoder, point.x.MinEncodedSize());
        point.y.Encode(yEncoder, point.y.MinEncodedSize());

        // Concatenate the encoded X and Y coordinates
        string encoded = encodedX + encodedY;

        return encoded;
}
